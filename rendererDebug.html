<!DOCTYPE html>
<html lang="en">
<head>
    <title>Asset Renderer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
</head>
<body>
<canvas id="glCanvas" width="800" height="600"></canvas>
<script>
    // JavaScript code
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

    if (!gl) {
        alert('Unable to initialize WebGL. Your browser may not support it.');
    }

    const vertexShaderSource = `
        attribute vec2 aPosition;
        attribute vec2 aTexCoord;

        uniform mat4 uProjectionMatrix;
        uniform vec2 uTranslation;

        varying vec2 vTexCoord;

        void main(void) {
            // Apply translation to position the asset
            vec2 position = aPosition + uTranslation;
            // Transform the position using the projection matrix
            gl_Position = uProjectionMatrix * vec4(position, 0.0, 1.0);
            // Pass the texture coordinate to the fragment shader
            vTexCoord = aTexCoord;
        }
    `;

    const fragmentShaderSource = `
        precision mediump float;

        uniform sampler2D uTexture;

        varying vec2 vTexCoord;

        void main(void) {
            gl_FragColor = texture2D(uTexture, vTexCoord);
        }
    `;

    const skinId = 1058;

    const start = async function(){
        // Compile shaders
        const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);

        // Create shader program
        const shaderProgram = createProgram(gl, vertexShader, fragmentShader);

        const skinAssetDataReq = await fetch("./" + skinId + "/" + skinId+ "-SkinAsset.json");
        const skinAsset = await skinAssetDataReq.json();

        // Prepare to load the texture
        const texture = gl.createTexture();
        const image = new Image();
        image.src = './' + skinId + '/' + skinId + '.png';
        image.onload = function() {
            // Bind the texture object
            gl.bindTexture(gl.TEXTURE_2D, texture);

            // Flip the image's Y axis to match WebGL's texture coordinate system
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

            // Set texture parameters
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

            // Upload the image into the texture
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,
                gl.RGBA, gl.UNSIGNED_BYTE, image);

            // Proceed to render the assets
            renderAssets(skinAsset, shaderProgram, texture, image);
        };

        function renderAssets(skinAsset, shaderProgram, texture, image) {
            // Use the shader program
            gl.useProgram(shaderProgram);

            // Enable blending for transparency
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            // Get attribute locations
            const aPosition = gl.getAttribLocation(shaderProgram, 'aPosition');
            const aTexCoord = gl.getAttribLocation(shaderProgram, 'aTexCoord');

            // Get uniform locations
            const uProjectionMatrix = gl.getUniformLocation(shaderProgram, 'uProjectionMatrix');
            const uTranslation = gl.getUniformLocation(shaderProgram, 'uTranslation');
            const uTexture = gl.getUniformLocation(shaderProgram, 'uTexture');

            // Set the texture uniform
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.uniform1i(uTexture, 0);

            // Set up the projection matrix
            const projectionMatrix = mat4.create();
            mat4.ortho(projectionMatrix, 0, canvas.width, 0, canvas.height, -1, 1);
            gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);

            // Grid configuration
            const gridColumns = 5; // Number of columns in the grid
            const spriteMargin = 10; // Margin between sprites

            // Assets array
            const assets = skinAsset.m_values.Array;
            const assetDimensions = [];

            // Calculate dimensions for each asset
            assets.forEach((asset, idx) => {
                const skinChunks = asset.skinChunks.Array;
                // Process the first skin chunk for simplicity
                const skinChunk = skinChunks[0];

                const begin = skinChunk.startVertexIndex;
                const count = skinChunk.vertexCount;

                const vertices = skinAsset.vertices.Array.slice(begin, begin + count);

                // Calculate bounding box
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;

                vertices.forEach(vertex => {
                    if (vertex.pos.x < minX) minX = vertex.pos.x;
                    if (vertex.pos.x > maxX) maxX = vertex.pos.x;
                    if (vertex.pos.y < minY) minY = vertex.pos.y;
                    if (vertex.pos.y > maxY) maxY = vertex.pos.y;
                });

                const width = maxX - minX;
                const height = maxY - minY;

                assetDimensions.push({ width, height, minX, minY });
            });

            // Calculate column widths and xOffsets
            const columnWidths = [];
            const xOffsets = [];
            let cumulativeWidth = 0;
            for (let col = 0; col < gridColumns; col++) {
                let maxWidthInColumn = 0;
                for (let idx = col; idx < assets.length; idx += gridColumns) {
                    const dim = assetDimensions[idx];
                    if (dim.width > maxWidthInColumn) {
                        maxWidthInColumn = dim.width;
                    }
                }
                columnWidths[col] = maxWidthInColumn + spriteMargin;
                xOffsets[col] = cumulativeWidth;
                cumulativeWidth += columnWidths[col];
            }

            // Calculate row heights and yOffsets
            const numRows = Math.ceil(assets.length / gridColumns);
            const rowHeights = [];
            const yOffsets = [];
            let cumulativeHeight = 0;
            for (let row = 0; row < numRows; row++) {
                let maxHeightInRow = 0;
                for (let idx = row * gridColumns; idx < (row + 1) * gridColumns && idx < assets.length; idx++) {
                    const dim = assetDimensions[idx];
                    if (dim.height > maxHeightInRow) {
                        maxHeightInRow = dim.height;
                    }
                }
                rowHeights[row] = maxHeightInRow + spriteMargin;
                yOffsets[row] = cumulativeHeight;
                cumulativeHeight += rowHeights[row];
            }

            // Calculate global translation to center the grid on the canvas
            const gridWidth = cumulativeWidth - spriteMargin; // Remove last margin
            const gridHeight = cumulativeHeight - spriteMargin; // Remove last margin

            const globalTranslation = [
                (canvas.width / 2) - (gridWidth / 2),
                (canvas.height / 2) - (gridHeight / 2)
            ];

            // Clear the canvas
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);


            let onlyShowName = "19";

            console.log(skinAsset.vertices)
            // Now, render each asset
            assets.forEach((asset, idx) => {
                console.log(asset);
                if(asset.name != onlyShowName){
                    return;
                }
                const skinChunks = asset.skinChunks.Array;
                // Process the first skin chunk
                const skinChunk = skinChunks[0];

                const begin = skinChunk.startVertexIndex;
                const count = skinChunk.vertexCount;

                const vertices = skinAsset.vertices.Array.slice(begin, begin + count);

                const positions = [];
                const texCoords = [];

                vertices.forEach(vertex => {
                    positions.push(vertex.pos.x, vertex.pos.y);
                    texCoords.push(vertex.uv.x, 1 - vertex.uv.y); // No inversion needed
                });

                console.log("positions", positions);
                console.log("texCoords", texCoords);

                // Indices
                const indexBegin = skinChunk.startIndexIndex;
                const indexCount = skinChunk.indexCount;

                const indices = skinAsset.triangles.Array.slice(indexBegin, indexBegin + indexCount);

                console.log("indices", indices);
                // Create and bind buffers
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

                const texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);

                const indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

                // Bind position buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.enableVertexAttribArray(aPosition);
                gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

                // Bind texture coordinate buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.enableVertexAttribArray(aTexCoord);
                gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 0, 0);

                // Bind index buffer
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

                // Calculate grid position
                const col = idx % gridColumns;
                const row = Math.floor(idx / gridColumns);

                const xOffset = xOffsets[col];
                const yOffset = yOffsets[row];

                // Adjust translation to position the asset within its grid cell, plus global translation
                const dimensions = assetDimensions[idx];
                const translation = [
                    globalTranslation[0] + xOffset - dimensions.minX,
                    globalTranslation[1] + yOffset - dimensions.minY
                ];

                gl.uniform2fv(uTranslation, translation);

                console.log('Asset', idx, 'translation:', translation);

                // Draw the asset
                gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

                // Clean up buffers
                gl.deleteBuffer(positionBuffer);
                gl.deleteBuffer(texCoordBuffer);
                gl.deleteBuffer(indexBuffer);
            });
        }
    }

    function compileShader(gl, shaderSource, shaderType) {
        const shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);

        // Check for errors
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            const error = gl.getShaderInfoLog(shader);
            console.error('Shader compilation error:', error);
            gl.deleteShader(shader);
            return null;
        }

        return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        // Check for errors
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            const error = gl.getProgramInfoLog(program);
            console.error('Program linking error:', error);
            gl.deleteProgram(program);
            return null;
        }

        return program;
    }

    start();
</script>
</body>
</html>
