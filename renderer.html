<html lang="en">
    <head>
        <title>Big poutch renderer</title>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    </head>
    <body>
    <canvas id="glCanvas" width="800" height="600"></canvas>
    </body>
</html>

<script>
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

    if (!gl) {
        alert('Unable to initialize WebGL. Your browser may not support it.');
    }

    let vertexBuffer = [];
    let baseVertexBuffer = [];

    let triangleIndices = [];
    let baseTriangleIndices = [];

    const vertexShaderSource = `
            // Vertex Shader Source
            attribute vec2 aPosition;
            attribute vec2 aTexCoord;
            attribute vec4 aMultiplicativeColor;
            attribute vec4 aAdditiveColor;

            uniform mat4 uProjectionMatrix;
            uniform vec2 uTranslation;
            uniform vec2 uScale;
            uniform float uOutlineScale; // New uniform for outline scaling

            varying vec2 vTexCoord;
            varying vec4 vMultiplicativeColor;
            varying vec4 vAdditiveColor;

            void main(void) {
                // Apply scaling (object scale + outline scale)
                vec2 scaledPosition = aPosition * uScale * (uOutlineScale > 1.0 ? uOutlineScale : 1.0);

                // Apply translation
                vec2 translatedPosition = scaledPosition + uTranslation;

                // Apply projection
                gl_Position = uProjectionMatrix * vec4(translatedPosition, 0.0, 1.0);

                // Pass through texture coordinates and colors
                vTexCoord = aTexCoord;
                vMultiplicativeColor = aMultiplicativeColor;
                vAdditiveColor = aAdditiveColor;
            }
        `;

    const fragmentShaderSource = `
            // Fragment Shader Source
            precision mediump float;

            uniform sampler2D uTexture;
            uniform bool uIsOutline;

            varying vec2 vTexCoord;
            varying vec4 vMultiplicativeColor;
            varying vec4 vAdditiveColor;

            void main(void) {
                if (uIsOutline) {
                    // Render the outline color with its alpha
                    gl_FragColor = vMultiplicativeColor + vAdditiveColor;
                } else {
                    // Standard rendering with texture
                    vec4 texColor = texture2D(uTexture, vTexCoord);
                    gl_FragColor = (texColor * vMultiplicativeColor) + vAdditiveColor;
                }
            }
        `;

    const meshes = [];
    let scale = 1.0; // Default scale (no zoom)
    const scaleStep = 0.1; // Scale increment/decrement step


    const skinId = 1058;

    // Initialize variables to store mouse position
    let mouseX = 0;
    let mouseY = 0;

    // Variable to store the currently selected mesh
    let selectedMesh = null;

    // Add event listener for mouse movement
    canvas.addEventListener('mousemove', function(event) {
        const rect = canvas.getBoundingClientRect();
        mouseX = event.clientX - rect.left;
        mouseY = rect.height - (event.clientY - rect.top); // Flip Y-axis to match WebGL coordinates
    }, false);

    // Add event listener for mouse leave to deselect mesh
    canvas.addEventListener('mouseleave', function() {
        selectedMesh = null;
    }, false);

    const start = async () => {
        const skinAssetDataReq = await fetch("./" + skinId +"/" + skinId + "-SkinAsset.json")
        const skinAsset = await skinAssetDataReq.json();

        let keys = skinAsset.m_keys;
        let values = skinAsset.m_values;

        skinAsset.entries = {};
        for(let i = 0; i < keys.Array.length; i++) {
            skinAsset.entries[keys.Array[i]] = values.Array[i];
        }

        const anim = await readInstance("./" + skinId + "/" + skinId + "_AnimMarche_1.dat");

        let renderStates = Array(anim.NodeCount).fill().map(() => new RenderState());

        vertexBuffer = JSON.parse(JSON.stringify(skinAsset.vertices.Array));
        triangleIndices = skinAsset.triangles.Array;

        // just copy
        baseVertexBuffer = JSON.parse(JSON.stringify(vertexBuffer));
        baseTriangleIndices = JSON.parse(JSON.stringify(triangleIndices));


        // Compile shaders
        const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);

        // Create shader program
        const shaderProgram = createProgram(gl, vertexShader, fragmentShader);
        // Prepare to load the texture
        const texture = gl.createTexture();
        const image = new Image();
        image.src = './' + skinId + '/' + skinId + '.png';

        image.onload = function() {
            // Bind the texture object
            gl.bindTexture(gl.TEXTURE_2D, texture);

            // Flip the image's Y axis to match WebGL's texture coordinate system
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

            // Set texture parameters
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

            // Upload the image into the texture
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,
                gl.RGBA, gl.UNSIGNED_BYTE, image);

            startRendering();
        };


        let startRendering = function () {
            let currentFrame = 0;

            setInterval(() => {
                currentFrame++;
                if (currentFrame >= anim.FrameCount) {
                    currentFrame = 0;
                }

                const bounds = computeFrame(anim, currentFrame, renderStates, skinAsset);
                render(skinAsset, shaderProgram, texture, bounds);
            }, 1000 / 30);
        }

        function render(skinAsset, shaderProgram, texture, animationBoundingBox) {
            // Use the shader program
            gl.useProgram(shaderProgram);

            // Enable blending for transparency
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);


            // Get attribute locations
            const aPosition = gl.getAttribLocation(shaderProgram, 'aPosition');
            const aTexCoord = gl.getAttribLocation(shaderProgram, 'aTexCoord');
            const aMultiplicativeColor = gl.getAttribLocation(shaderProgram, 'aMultiplicativeColor');
            const aAdditiveColor = gl.getAttribLocation(shaderProgram, 'aAdditiveColor');


            // Get uniform locations
            const uProjectionMatrix = gl.getUniformLocation(shaderProgram, 'uProjectionMatrix');
            const uTranslation = gl.getUniformLocation(shaderProgram, 'uTranslation');
            const uTexture = gl.getUniformLocation(shaderProgram, 'uTexture');
            const uScaleLocation = gl.getUniformLocation(shaderProgram, 'uScale');

            // Set the texture uniform
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.uniform1i(uTexture, 0);

            // Set up the projection matrix
            const projectionMatrix = mat4.create();
            mat4.ortho(projectionMatrix, 0, canvas.width, 0, canvas.height, -1, 1);
            gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
            gl.uniform2f(uScaleLocation, scale, scale);

            // Clear the canvas
            gl.clearColor(255.0, 255.0, 255.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Perform hit detection based on the overall bounding box
            if (isMouseOverAnimation(animationBoundingBox)) {
                console.log('Mouse is over the animation!');
                for(let meshKey in meshes) {
                    const mesh = meshes[meshKey];
                    renderOutline(mesh, shaderProgram, texture);
                }
            }

            gl.uniform1i(gl.getUniformLocation(shaderProgram, 'uIsOutline'), false);
            gl.uniform1f(gl.getUniformLocation(shaderProgram, 'uOutlineScale'), 1.0);

            for(let meshKey in meshes){
                const mesh = meshes[meshKey];

                const positions = [];
                const texCoords = [];
                const multiplicativeColors = [];
                const additiveColors = [];

                // Vertices
                mesh.vertex.forEach(vertex => {
                    positions.push(vertex.pos.x, vertex.pos.y);
                    texCoords.push(vertex.uv.x, (1 - vertex.uv.y));

                    const multiplicativeColor = ConvertFromEncodedColor(vertex.multiplicativeColor);
                    const additiveColor = ConvertFromEncodedColor(vertex.additiveColor);

                    // Push RGBA components normalized to [0,1]
                    multiplicativeColors.push(
                        multiplicativeColor.r,
                        multiplicativeColor.g,
                        multiplicativeColor.b,
                        multiplicativeColor.a
                    );

                    additiveColors.push(
                        additiveColor.r,
                        additiveColor.g,
                        additiveColor.b,
                        additiveColor.a
                    );
                });

                const indices = mesh.indices;

                // Create and bind buffers

                const positionBuffer = gl.createBuffer();
                const indexBuffer = gl.createBuffer();
                const texCoordBuffer = gl.createBuffer();
                const multiplicativeColorBuffer = gl.createBuffer();
                const additiveColorBuffer = gl.createBuffer();

                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

                // Bind and upload multiplicative color data
                gl.bindBuffer(gl.ARRAY_BUFFER, multiplicativeColorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(multiplicativeColors), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(aMultiplicativeColor);
                gl.vertexAttribPointer(aMultiplicativeColor, 4, gl.FLOAT, false, 0, 0);

                // Bind and upload additive color data
                gl.bindBuffer(gl.ARRAY_BUFFER, additiveColorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(additiveColors), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(aAdditiveColor);
                gl.vertexAttribPointer(aAdditiveColor, 4, gl.FLOAT, false, 0, 0);

                // Bind position buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.enableVertexAttribArray(aPosition);
                gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

                // Bind texture coordinate buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.enableVertexAttribArray(aTexCoord);
                gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 0, 0);

                // Bind index buffer
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

                gl.uniform2fv(uTranslation, [400, 250]);

                // Draw the asset
                gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

                // Clean up buffers
                gl.deleteBuffer(positionBuffer);
                gl.deleteBuffer(texCoordBuffer);
                gl.deleteBuffer(indexBuffer);
                gl.deleteBuffer(multiplicativeColorBuffer);
                gl.deleteBuffer(additiveColorBuffer);
            }
        }
    };
    /**
     * Renders a blurred outline around the entire animation.
     * @param {Object} boundingBox - The overall bounding box of the animation.
     * @param {WebGLProgram} shaderProgram - The shader program.
     */
    /**
     * Renders a blurred outline around the selected mesh.
     * @param {Object} mesh - The selected mesh object.
     * @param {WebGLProgram} shaderProgram - The shader program.
     * @param {WebGLTexture} texture - The texture to use.
     */
    function renderOutline(mesh, shaderProgram, texture) {
        const aPosition = gl.getAttribLocation(shaderProgram, 'aPosition');
        const aTexCoord = gl.getAttribLocation(shaderProgram, 'aTexCoord');
        const aMultiplicativeColor = gl.getAttribLocation(shaderProgram, 'aMultiplicativeColor');
        const aAdditiveColor = gl.getAttribLocation(shaderProgram, 'aAdditiveColor');
        const uTranslation = gl.getUniformLocation(shaderProgram, 'uTranslation');
        const uScaleLocation = gl.getUniformLocation(shaderProgram, 'uScale');

        // Define outline color (e.g., semi-transparent black)
        const outlineColor = [0.0, 0.0, 0.0, 0.3]; // RGBA

        // Define number of blur passes
        const blurPasses = 4;
        const blurScaleStep = 0.10; // Scale increment per pass

        for (let i = 1; i <= blurPasses; i++) {
            // Create buffers for outline
            const outlinePositionBuffer = gl.createBuffer();
            const outlineIndexBuffer = gl.createBuffer();
            const outlineTexCoordBuffer = gl.createBuffer();
            const outlineMultiplicativeColorBuffer = gl.createBuffer();
            const outlineAdditiveColorBuffer = gl.createBuffer();

            // Prepare outline vertices (scaled up)
            const outlinePositions = [];
            const outlineTexCoords = [];
            const outlineMultiplicativeColors = [];
            const outlineAdditiveColors = [];

            mesh.vertex.forEach(vertex => {
                // Apply additional scaling for outline
                const scaledX = vertex.pos.x * (1 + blurScaleStep * i);
                const scaledY = vertex.pos.y * (1 + blurScaleStep * i);

                // we need to
                outlinePositions.push(scaledX, scaledY);

                outlineTexCoords.push(vertex.uv.x, (1 - vertex.uv.y));

                // Set multiplicative color to the outline color
                outlineMultiplicativeColors.push(
                    outlineColor[0],
                    outlineColor[1],
                    outlineColor[2],
                    outlineColor[3]
                );

                // No additive color for outline
                outlineAdditiveColors.push(
                    0.0,
                    0.0,
                    0.0,
                    0.0
                );
            });

            const outlineIndices = mesh.indices;

            // Bind and upload outline buffers
            gl.bindBuffer(gl.ARRAY_BUFFER, outlinePositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(outlinePositions), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, outlineTexCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(outlineTexCoords), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, outlineIndexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(outlineIndices), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, outlineMultiplicativeColorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(outlineMultiplicativeColors), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(aMultiplicativeColor);
            gl.vertexAttribPointer(aMultiplicativeColor, 4, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, outlineAdditiveColorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(outlineAdditiveColors), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(aAdditiveColor);
            gl.vertexAttribPointer(aAdditiveColor, 4, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, outlinePositionBuffer);
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, outlineTexCoordBuffer);
            gl.enableVertexAttribArray(aTexCoord);
            gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, outlineIndexBuffer);

            // Set translation same as original mesh
            gl.uniform2fv(uTranslation, [400, 250]);

            // Set the scale uniform same as original mesh
            gl.uniform2f(uScaleLocation, scale, scale);

            // Set blending for the outline (additive blending for blur effect)
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            // Draw the outline
            gl.drawElements(gl.TRIANGLES, outlineIndices.length, gl.UNSIGNED_SHORT, 0);

            // Re-enable additive color for subsequent meshes
            gl.enableVertexAttribArray(aAdditiveColor);
            gl.vertexAttribPointer(aAdditiveColor, 4, gl.FLOAT, false, 0, 0);

            // Clean up outline buffers
            gl.deleteBuffer(outlinePositionBuffer);
            gl.deleteBuffer(outlineTexCoordBuffer);
            gl.deleteBuffer(outlineIndexBuffer);
            gl.deleteBuffer(outlineMultiplicativeColorBuffer);
            gl.deleteBuffer(outlineAdditiveColorBuffer);
        }
    }


    /**
     * Determines if the mouse is over the animation based on its bounding box.
     * @param {Object} boundingBox - The overall bounding box of the animation.
     * @returns {boolean} True if the mouse is over the animation, false otherwise.
     */
    function isMouseOverAnimation(boundingBox) {
        // Apply scaling and translation to the bounding box
        const transformedMinX = boundingBox.minX * scale + 400; // 400 is uTranslation.x
        const transformedMinY = boundingBox.minY * scale + 250; // 250 is uTranslation.y
        const transformedMaxX = boundingBox.maxX * scale + 400;
        const transformedMaxY = boundingBox.maxY * scale + 250;

        // Check if mouse coordinates are within the transformed bounding box
        return (
            mouseX >= transformedMinX &&
            mouseX <= transformedMaxX &&
            mouseY >= transformedMinY &&
            mouseY <= transformedMaxY
        );
    }


    function compileShader(gl, shaderSource, shaderType) {
        const shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);

        // Check for errors
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            const error = gl.getShaderInfoLog(shader);
            console.error('Shader compilation error:', error);
            gl.deleteShader(shader);
            return null;
        }

        return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        // Check for errors
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            const error = gl.getProgramInfoLog(program);
            console.error('Program linking error:', error);
            gl.deleteProgram(program);
            return null;
        }

        return program;
    }

    async function readInstance(fileName){
        const req = await fetch(fileName);
        const data = await req.arrayBuffer();

        const dataView = new DataView(data);
        // we read a string because thats how it's currently stored in unity
        let strLen = dataView.getUint32(0, true);

        let str = new TextDecoder('utf-8').decode(new Uint8Array(data.slice(4, 4 + strLen)));

        let bytesOffset = (4 + strLen + 4);

        if(bytesOffset % 4 !== 0){
            bytesOffset += 4 - (bytesOffset % 4);
        }

        return new AnimationInstance(fileName, data.slice(bytesOffset));
    }


    class AnimationInstance {
        constructor(guid, data) {
            this.Guid = guid;
            this.referenceCount = 0;

            const dataView = new DataView(data);
            let startIndex = 0;

            // Read Header Information
            this.FrameCount = dataView.getUint16(startIndex, true); // Little-endian
            startIndex += 2;

            this.NodeCount = dataView.getUint16(startIndex, true);
            startIndex += 2;

            this.LabelCount = dataView.getUint16(startIndex, true);
            startIndex += 2;

            this.CombinedNodeState = dataView.getUint8(startIndex);
            startIndex += 2; // Note: In C# code, after reading a byte at index 6, startIndex is set to 8


            // Process Labels
            this.Labels = [];
            if (this.LabelCount > 0) {
                for (let i = 0; i < this.LabelCount; ++i) {
                    const pos = dataView.getUint16(startIndex, true);
                    const count = dataView.getUint8(startIndex + 2);

                    // Read the label string
                    const labelBytes = new Uint8Array(data.slice(startIndex + 3, startIndex + 3 + count));
                    const label = new TextDecoder('utf-8').decode(labelBytes);

                    this.Labels.push(new AnimationLabel(pos, label));

                    startIndex = startIndex + 3 + count;

                    // Align startIndex to the next even number
                    if (startIndex % 2 !== 0) {
                        startIndex += 1;
                    }
                }

                // Align startIndex to the next multiple of 4
                while (startIndex % 4 !== 0) {
                    startIndex += 1;
                }
            }

            // Read Frame Data Positions
            this.FrameDataPositions = [];
            for (let i = 0; i < this.FrameCount; ++i) {
                const frameDataPosition = dataView.getInt32(startIndex, true);
                this.FrameDataPositions.push(frameDataPosition);
                startIndex += 4;
            }

            // Store the data
            this.Data = data;
        }

    }

    // Helper class for AnimationLabel
    class AnimationLabel {
        constructor(pos, label) {
            this.pos = pos;
            this.label = label;
        }
    }

    class RenderState {
        constructor() {
            this.Reset();
        }

        /**
         * Parses the animation data to populate RenderState properties.
         * @param {Uint8Array} animationData - The binary animation data.
         * @param {number} dataPosition - The starting byte position for parsing.
         * @returns {number} The updated byte position after parsing.
         */
        compute(animationData, dataPosition) {
            if (!animationData) {
                throw new Error("animationData is null or undefined.");
                // In C++, sub_18076B300(this, 0LL, dataPosition, dataPosition);
                // Here, throwing an error as a placeholder
            }

            const dataView = new DataView(animationData.buffer, animationData.byteOffset, animationData.byteLength);
            const max_length = animationData.length;

            if (dataPosition >= max_length) {
                throw new Error("dataPosition exceeds animationData length.");
                // In C++, goto LABEL_28 which calls sub_18076B2F0();
                // Here, throwing an error as a placeholder
            }

            const v8 = animationData[dataPosition];
            // Handle alpha if flag 0x02 is set
            if ((v8 & 0x02) !== 0) {
                if (dataPosition + 1 >= max_length) {
                    throw new Error("Insufficient data for alpha.");
                }
                this.alpha = animationData[dataPosition + 1];
            }

            const v9 = v8;
            let v10 = dataPosition + 2;
            const v11 = (dataPosition + 2) % 4;
            if (v11 !== 0) {
                v10 = alignTo4Bytes(v10);
            }

            // Handle spriteIndex, customisationIndex, childrenRecursiveCount if flags 0x21 are set
            if ((v9 & 0x21) !== 0) {
                if (v10 + 6 > max_length) {
                    throw new Error("Insufficient data for spriteIndex, customisationIndex, and childrenRecursiveCount.");
                }

                this.spriteIndex = readInt16(dataView, v10);
                this.customisationIndex = readInt16(dataView, v10 + 2);
                this.childrenRecursiveCount = readInt16(dataView, v10 + 4);

                v10 += 6;
                if (v10 % 4 !== 0) {
                    v10 = alignTo4Bytes(v10);
                }
            }

            // Handle multiplicativeColor if flag 0x04 is set
            if ((v9 & 0x04) !== 0) {
                if (v10 + 4 > max_length) {
                    throw new Error("Insufficient data for multiplicativeColor.");
                }
                this.multiplicativeColor = readUint32(dataView, v10);
                v10 += 4;
            }

            // Handle additiveColor if flag 0x08 is set
            if ((v9 & 0x08) !== 0) {
                if (v10 + 4 > max_length) {
                    throw new Error("Insufficient data for additiveColor.");
                }
                this.additiveColor = readUint32(dataView, v10);
                v10 += 4;
            }

            // Handle transformation matrices if flag 0x10 is set
            if ((v9 & 0x10) !== 0) {
                if (v10 + 24 > max_length) {
                    throw new Error("Insufficient data for transformation matrices.");
                }
                this.m00 = readFloat32(dataView, v10);
                this.m01 = readFloat32(dataView, v10 + 4);
                this.m03 = readFloat32(dataView, v10 + 8);
                this.m10 = readFloat32(dataView, v10 + 12);
                this.m11 = readFloat32(dataView, v10 + 16);
                this.m13 = readFloat32(dataView, v10 + 20);
                v10 += 24;
            }

            // Handle maskFlags if flag 0x40 is set
            if ((v9 & 0x40) !== 0) {
                if (v10 + 1 > max_length) {
                    throw new Error("Insufficient data for maskFlags.");
                }
                this.maskFlags = animationData[v10];
                v10 += 1;
            }

            // Interpret v9 as signed char to check if negative
            const signed_v9 = v9 >= 128 ? v9 - 256 : v9;
            if (signed_v9 < 0) {
                // Call ComputeExtendedFilterAndBlendState
                v10 = this.computeExtendedFilterAndBlendState(animationData, v10);
            }

            return v10;

        }


        /**
         * Parses extended filter and blend state data from the animation data.
         * @param {Uint8Array} animationData - The binary animation data.
         * @param {number} dataPosition - The current byte position for parsing.
         * @returns {number} The updated byte position after parsing.
         */
        computeExtendedFilterAndBlendState(animationData, dataPosition) {
            const dataView = new DataView(animationData.buffer, animationData.byteOffset, animationData.byteLength);
            const max_length = animationData.length;

            if (dataPosition >= max_length) {
                throw new Error("dataPosition exceeds animationData length in extended parsing.");
            }

            const blendMode = animationData[dataPosition];
            this.blendMode = blendMode;
            dataPosition += 1;

            // Example Implementation:
            // Assuming blendMode indicates how to parse the following data
            // For demonstration, we'll handle specific blend modes
            // In practice, adjust based on actual data specifications

            while (blendMode > 0) {
                if (dataPosition >= max_length) {
                    throw new Error("Insufficient data for filters.");
                }

                const filterType = animationData[dataPosition];
                dataPosition += 1;

                switch (filterType) {
                    case 1: // Drop Shadow
                        if (dataPosition + 16 > max_length) {
                            throw new Error("Insufficient data for Drop Shadow filter.");
                        }
                        this.dropShadow = {
                            offsetX: readFloat32(dataView, dataPosition),
                            offsetY: readFloat32(dataView, dataPosition + 4),
                            blurRadius: readFloat32(dataView, dataPosition + 8),
                            color: readUint32(dataView, dataPosition + 12)
                        };
                        dataPosition += 16; // 4 floats: 16 bytes
                        break;
                    case 2: // Blur
                        if (dataPosition + 4 > max_length) {
                            throw new Error("Insufficient data for Blur filter.");
                        }
                        this.blur = {
                            blurRadius: readFloat32(dataView, dataPosition)
                        };
                        dataPosition += 4; // 1 float: 4 bytes
                        break;
                    case 4: // Glow
                        if (dataPosition + 12 > max_length) {
                            throw new Error("Insufficient data for Glow filter.");
                        }
                        this.glow = {
                            intensity: readFloat32(dataView, dataPosition),
                            color: readUint32(dataView, dataPosition + 4),
                            spread: readFloat32(dataView, dataPosition + 8)
                        };
                        dataPosition += 12; // 3 floats: 12 bytes
                        break;
                    default:
                        throw new Error(`Unknown filter type: ${filterType}`);
                }

                // Update blendMode if multiple filters are encoded
                // This depends on how blendMode is represented in the data
                // For simplicity, assuming one filter per call
                break;
            }

            return dataPosition;
        }
        Reset() {
            this.m00 = 1.0;
            this.m01 = 0.0;
            this.m03 = 0.0;
            this.m10 = 0.0;
            this.m11 = 1.0;
            this.m13 = 0.0;
            this.spriteIndex = -1;
            this.alpha = 255; // Equivalent to byte.MaxValue
            this.multiplicativeColor = ColorHelpers.SWFColorOpaqueWhite;
            this.additiveColor = ColorHelpers.SWFColorTransparentBlack;
            this.maskFlags = Animation.MaskFlags.None;
            this.blendMode = Animation.FlashBlendMode.Normal; // Set default blend mode if applicable
            this.colorMatrix = null;
            this.customisationIndex = -1;
            this.childrenRecursiveCount = 0;
        }
    }

    const Animation = {
        MaskFlags: {
            None: 0,
            // Define other mask flags
        },
        FlashBlendMode: {
            Normal: 0,
            // Define other blend modes
        },
        ExtendedFilterAndBlendState: {
            None: 0,
            ColorMatrixFilter: 1 << 0,
            // Define other flags
        },
    };

    class Vector4 {
        constructor(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
    }

    const ColorHelpers = {
        SWFColorOpaqueWhite: 0xffffffff,
        SWFColorTransparentBlack: 0x00000000,
    };

    function SkipToJustBeforeFrame(animation, frame, renderStates){
        let frameDataPositions = animation.FrameDataPositions;

        for(let i = 0; i < frame; i++){
            let dataPosition = frameDataPositions[i];

            for(let j = animation.NodeCount; j >= 0; j--){
                if(dataPosition >= animation.Data.byteLength){
                    break;
                }

                let dataView = new DataView(animation.Data, dataPosition);
                let nodeNum = dataView.getUint16(0, true);
                dataPosition += 2;

                dataPosition = renderStates[nodeNum].compute(new Uint8Array(animation.Data), dataPosition);
            }
        }
    }

    function computeFrame(animation, frame, renderStates, skinAsset) {
        let nodeCount = animation.NodeCount;
        let bytes = animation.Data;
        let frameDataPositions = animation.FrameDataPositions;

        let dataPosition = frameDataPositions[frame];
        vertexBuffer = [];
        triangleIndices = [];

        meshes.length = 0;

        for(let i = 0; i < renderStates.length; i++){
            renderStates[i].Reset();
        }

        // reset render states
        SkipToJustBeforeFrame(animation, frame, renderStates);

        const frameBounds = new Bounds(new Vector2(0,0), new Vector2(0,0));

        let nodesCount = nodeCount - 1;
        while (nodesCount >= 0 && dataPosition < bytes.byteLength)
        {
            // we have to copy it because it's modified everytime
            // C'EST SUPER MAL OPTIMISÉ FRANCHEMENT MAIS ÇA DEMANDE UN PEU TROP DE CHANGEMENT DE MODIFIER ÇA
            baseVertexBuffer = JSON.parse(JSON.stringify(skinAsset.vertices.Array));

            let dataView = new DataView(bytes, dataPosition);
            // we get a ushort to get the node num
            let nodeNum = dataView.getUint16(0, true);

            dataPosition += 2;

            dataPosition = renderStates[nodeNum].compute(new Uint8Array(bytes), dataPosition);
            let renderState = renderStates[nodeNum];

            // we have to find the skinasset.parts at index of render state of spriteIndex
            // safely, if it's not inside the array, we skip
            //console.log(renderStates[nodeNum].spriteIndex)
            let part = Object.values(skinAsset.entries)[renderStates[nodeNum].spriteIndex];

            if(part === undefined) {
                nodesCount--;
                continue;
            }

            //console.log('rendering', nodeNum, renderState.spriteIndex, part);
            //console.log('renderState', renderState);

            for(let p in part.skinChunks.Array){
                let skinChunk = part.skinChunks.Array[p];
                const newVertices = [];

                let partBounds = transformVerticesIntoList(newVertices,
                    baseVertexBuffer,
                    skinChunk.startVertexIndex,
                    skinChunk.vertexCount,
                    renderState);

                vertexBuffer = vertexBuffer.concat(newVertices);


                frameBounds.encapsulate(partBounds);

                const newTriangleIndices = [];
                offsetIndicesIntoList(newTriangleIndices,
                    baseTriangleIndices,
                    skinChunk.startIndexIndex,
                    skinChunk.indexCount,
                    /*count*/ 0);

                triangleIndices = triangleIndices.concat(newTriangleIndices);

                let mesh = {
                    nodeNum: nodeNum,
                    part: part,
                    renderState: renderState,
                    vertex: newVertices,
                    indices: newTriangleIndices,
                };
                meshes.push(mesh);

            }

            nodesCount--;
        }

        return frameBounds;
    }

    function offsetIndicesIntoList(destination, source, startIndex, indexCount, offset) {
        let num = startIndex + indexCount;
        for (let i = startIndex; i < num; i++)
        {
            destination.push(source[i] + offset);
        }
    }

    class Color {
        constructor(r, g, b, a) {
            this.r = r; // Range: approximately -1.0 to 0.992
            this.g = g;
            this.b = b;
            this.a = a;
        }
    }

    function toSignedByte(n) {
        return n < 128 ? n : n - 256;
    }

    // ConvertSWFColor function
    // ConvertSWFColor function
    function ConvertSWFColor(r, g, b, a = 1.0) {
        // Helper function to clamp and floor the value
        function clampAndFloor(val) {
            return Math.max(Math.min(Math.floor(val * 128), 127), -128);
        }

        // Helper function to convert signed byte to unsigned byte
        function toUnsignedByte(sbyte) {
            return (sbyte < 0) ? (256 + sbyte) : sbyte;
        }

        // Clamp and floor each component
        const redSByte = clampAndFloor(r);
        const greenSByte = clampAndFloor(g);
        const blueSByte = clampAndFloor(b);
        const alphaSByte = clampAndFloor(a);

        // Convert to unsigned bytes
        const redByte = toUnsignedByte(redSByte);
        const greenByte = toUnsignedByte(greenSByte);
        const blueByte = toUnsignedByte(blueSByte);
        const alphaByte = toUnsignedByte(alphaSByte);

        // Pack into a 32-bit unsigned integer
        const color = (redByte | (greenByte << 8) | (blueByte << 16) | (alphaByte << 24)) >>> 0;

        return color;
    }

    // ConvertFromEncodedColor function
    function ConvertFromEncodedColor(encodedColor) {
        // Helper function to convert unsigned byte to signed byte
        function fromUnsignedByte(byte) {
            return (byte >= 128) ? (byte - 256) : byte;
        }

        // Unpack each byte
        const redByte = encodedColor & 0xFF;
        const greenByte = (encodedColor >> 8) & 0xFF;
        const blueByte = (encodedColor >> 16) & 0xFF;
        const alphaByte = (encodedColor >> 24) & 0xFF;

        // Convert to signed bytes
        const red = fromUnsignedByte(redByte);
        const green = fromUnsignedByte(greenByte);
        const blue = fromUnsignedByte(blueByte);
        const alpha = fromUnsignedByte(alphaByte);

        // Normalize to [0, 1] range
        const r = red / 128.0;
        const g = green / 128.0;
        const b = blue / 128.0;
        const a = alpha / 128.0;

        return new Color(r, g, b, a);
    }

    function transformVertex(renderState, vertex) {
        // Get the current position of the vertex
        const pos = vertex.pos;

        // Transform the position using the render state's transformation matrix
        const newX = renderState.m00 * pos.x + renderState.m01 * pos.y + renderState.m03;
        const newY = renderState.m10 * pos.x + renderState.m11 * pos.y + renderState.m13;

        // Update the vertex position
        vertex.pos.x = newX;
        vertex.pos.y = newY;

        // Convert the encoded multiplicative color to RGBA components
        const color = ConvertFromEncodedColor(vertex.multiplicativeColor);

        // Adjust the alpha component based on the render state's alpha value
        const adjustedAlpha = color.a * (renderState.alpha / 255);

        // Update the vertex's multiplicative color
        vertex.multiplicativeColor = ConvertSWFColor(color.r, color.g, color.b, adjustedAlpha);

        // Return the modified vertex
        return vertex;
    }

    function transformVerticesIntoList(destination, source, startVertexIndex, vertexCount, renderState) {
        const num = startVertexIndex + vertexCount;
        let vector = Vector2.positiveInfinity();
        let vector2 = Vector2.negativeInfinity();

        for (let i = startVertexIndex; i < num; i++) {
            const animationGeometryVertex = transformVertex(renderState, source[i]);
            destination.push(animationGeometryVertex);
            vector = Vector2.Min(vector, animationGeometryVertex.pos);
            vector2 = Vector2.Max(vector2, animationGeometryVertex.pos);
        }

        const vector3 = vector.add(vector2).multiply(0.5);
        return new Bounds(vector3, vector2.subtract(vector3));
    }

    class Bounds {
        constructor(center, size) {
            this.center = center;
            this.size = size;
        }

        // Getter for min
        get min() {
            if(this.size.x === 0 && this.size.y === 0){
                return this.size;
            }

            const halfSize = this.size.multiply(0.5);
            return this.center.subtract(halfSize);
        }

        // Getter for max
        get max() {
            if(this.size.x === 0 && this.size.y === 0){
                return this.size;
            }

            const halfSize = this.size.multiply(0.5);
            return this.center.add(halfSize);
        }

        get minX() {
            return this.min.x;
        }

        get minY() {
            return this.min.y;
        }

        get maxX() {
            return this.max.x;
        }

        get maxY() {
            return this.max.y;
        }

        encapsulate(bounds) {
            // Calculate new min and max
            const newMin = Vector2.Min(this.min, bounds.min);
            const newMax = Vector2.Max(this.max, bounds.max);

            // Update center and size
            this.center = newMin.add(newMax).multiply(0.5);
            this.size = newMax.subtract(newMin);
        }
    }

    class Vector2 {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        // Static method to return positive infinity vector
        static positiveInfinity() {
            return new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
        }

        // Static method to return negative infinity vector
        static negativeInfinity() {
            return new Vector2(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
        }

        // Static method to find the minimum of two vectors
        static Min(a, b) {
            return new Vector2(Math.min(a.x, b.x), Math.min(a.y, b.y));
        }

        // Static method to find the maximum of two vectors
        static Max(a, b) {
            return new Vector2(Math.max(a.x, b.x), Math.max(a.y, b.y));
        }

        // Method to add two vectors
        add(other) {
            return new Vector2(this.x + other.x, this.y + other.y);
        }

        // Method to subtract two vectors
        subtract(other) {
            return new Vector2(this.x - other.x, this.y - other.y);
        }

        // Method to multiply vector by scalar
        multiply(scalar) {
            return new Vector2(this.x * scalar, this.y * scalar);
        }


    }

    /**
     * Reads a signed 16-bit integer from the DataView at the specified byte offset.
     * @param {DataView} dataView - The DataView instance.
     * @param {number} offset - The byte offset to read from.
     * @returns {number} The read signed 16-bit integer.
     */
    function readInt16(dataView, offset) {
        return dataView.getInt16(offset, true); // Little-endian
    }

    /**
     * Reads an unsigned 32-bit integer from the DataView at the specified byte offset.
     * @param {DataView} dataView - The DataView instance.
     * @param {number} offset - The byte offset to read from.
     * @returns {number} The read unsigned 32-bit integer.
     */
    function readUint32(dataView, offset) {
        return dataView.getUint32(offset, true); // Little-endian
    }

    /**
     * Reads a 32-bit float from the DataView at the specified byte offset.
     * @param {DataView} dataView - The DataView instance.
     * @param {number} offset - The byte offset to read from.
     * @returns {number} The read 32-bit float.
     */
    function readFloat32(dataView, offset) {
        return dataView.getFloat32(offset, true); // Little-endian
    }

    /**
     * Aligns the given position to the next multiple of 4.
     * @param {number} position - The current byte position.
     * @returns {number} The aligned byte position.
     */
    function alignTo4Bytes(position) {
        return position % 4 === 0 ? position : position - (position % 4) + 4;
    }

    // Add event listener for mouse wheel to handle zoom
    canvas.addEventListener('wheel', function(event) {
        event.preventDefault(); // Prevent the page from scrolling

        // Determine the direction of the wheel scroll
        if (event.deltaY < 0) {
            // Zoom in
            scale += scaleStep;
            if (scale > 5.0) scale = 5.0; // Set an upper limit to zoom in
        } else {
            // Zoom out
            scale -= scaleStep;
            if (scale < 0.1) scale = 0.1; // Set a lower limit to zoom out
        }
    }, { passive: false });

    /**
     * Generates the outline vertices based on the bounding box.
     * @param {Object} boundingBox - The bounding box with min and max properties.
     * @returns {Float32Array} The array of outline vertices.
     */
    function generateOutlineVertices(boundingBox) {
        return new Float32Array([
            boundingBox.minX, boundingBox.minY,
            boundingBox.maxX, boundingBox.minY,
            boundingBox.maxX, boundingBox.maxY,
            boundingBox.minX, boundingBox.maxY
        ]);
    }

    start();

</script>